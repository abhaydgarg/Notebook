<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=description content="Notebook collections"><link href=https://abhaydgarg.github.io/Notebook/index.html/react/getDerivedStateFromProps/ rel=canonical><meta name=author content="Abhay Garg"><meta name=lang:clipboard.copy content="Copy to clipboard"><meta name=lang:clipboard.copied content="Copied to clipboard"><meta name=lang:search.language content=en><meta name=lang:search.pipeline.stopwords content=True><meta name=lang:search.pipeline.trimmer content=True><meta name=lang:search.result.none content="No matching documents"><meta name=lang:search.result.one content="1 matching document"><meta name=lang:search.result.other content="# matching documents"><meta name=lang:search.tokenizer content=[\s\-]+><link rel="shortcut icon" href=../../assets/images/favicon.png><meta name=generator content="mkdocs-1.0.4, mkdocs-material-4.4.2"><title>getDerivedStateFromProps - Notebook</title><link rel=stylesheet href=../../assets/stylesheets/application.30686662.css><link rel=stylesheet href=../../assets/stylesheets/application-palette.a8b3c06d.css><meta name=theme-color content=#2196f3><script src=../../assets/javascripts/modernizr.74668098.js></script><link href=https://fonts.gstatic.com rel=preconnect crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,400i,700|Ubuntu+Mono&display=fallback"><style>body,input{font-family:"Ubuntu","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Ubuntu Mono","Courier New",Courier,monospace}</style><link rel=stylesheet href=../../assets/fonts/material-icons.css></head> <body dir=ltr data-md-color-primary=blue data-md-color-accent=blue> <svg class=md-svg> <defs> <svg xmlns=http://www.w3.org/2000/svg width=416 height=448 viewbox="0 0 416 448" id=__github><path fill=currentColor d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg> </defs> </svg> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay data-md-component=overlay for=__drawer></label> <a href=#getderivedstatefromprops tabindex=1 class=md-skip> Skip to content </a> <header class=md-header data-md-component=header> <nav class="md-header-nav md-grid"> <div class=md-flex> <div class="md-flex__cell md-flex__cell--shrink"> <a href=https://abhaydgarg.github.io/Notebook/index.html title=Notebook class="md-header-nav__button md-logo"> <i class=md-icon></i> </a> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--menu md-header-nav__button" for=__drawer></label> </div> <div class="md-flex__cell md-flex__cell--stretch"> <div class="md-flex__ellipsis md-header-nav__title" data-md-component=title> <span class=md-header-nav__topic> Notebook </span> <span class=md-header-nav__topic> getDerivedStateFromProps </span> </div> </div> <div class="md-flex__cell md-flex__cell--shrink"> </div> <div class="md-flex__cell md-flex__cell--shrink"> <div class=md-header-nav__source> <a href=https://github.com/abhaydgarg/Notebook/ title="Go to repository" class=md-source data-md-source=github> <div class=md-source__icon> <svg viewbox="0 0 24 24" width=24 height=24> <use xlink:href=#__github width=24 height=24></use> </svg> </div> <div class=md-source__repository> GitHub </div> </a> </div> </div> </div> </nav> </header> <div class=md-container> <main class=md-main role=main> <div class="md-main__inner md-grid" data-md-component=container> <div class="md-sidebar md-sidebar--primary" data-md-component=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" data-md-level=0> <label class="md-nav__title md-nav__title--site" for=__drawer> <a href=https://abhaydgarg.github.io/Notebook/index.html title=Notebook class="md-nav__button md-logo"> <i class=md-icon></i> </a> Notebook </label> <div class=md-nav__source> <a href=https://github.com/abhaydgarg/Notebook/ title="Go to repository" class=md-source data-md-source=github> <div class=md-source__icon> <svg viewbox="0 0 24 24" width=24 height=24> <use xlink:href=#__github width=24 height=24></use> </svg> </div> <div class=md-source__repository> GitHub </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../computer-science/ title=CS class=md-nav__link> CS </a> </li> <li class=md-nav__item> <a href=../../parser/ title=Parser class=md-nav__link> Parser </a> </li> <li class=md-nav__item> <a href=../../data-structure-and-algorithms/ title="Data Structure and Algorithms" class=md-nav__link> Data Structure and Algorithms </a> </li> <li class=md-nav__item> <a href=../../oops/ title=OOPS class=md-nav__link> OOPS </a> </li> <li class=md-nav__item> <a href=../../design-patterns/ title="Design Patterns" class=md-nav__link> Design Patterns </a> </li> <li class=md-nav__item> <a href=../../regex/ title=Regex class=md-nav__link> Regex </a> </li> <li class=md-nav__item> <a href=../../git/ title=GIT class=md-nav__link> GIT </a> </li> <li class=md-nav__item> <a href=../../css/ title=CSS class=md-nav__link> CSS </a> </li> <li class=md-nav__item> <a href=../../rest-api/ title="REST API" class=md-nav__link> REST API </a> </li> <li class=md-nav__item> <a href=../../eslint/ title=ESLint class=md-nav__link> ESLint </a> </li> <li class=md-nav__item> <a href=../../javascript/ title=Javascript class=md-nav__link> Javascript </a> </li> <li class=md-nav__item> <a href=../../nodejs/ title=Node.js class=md-nav__link> Node.js </a> </li> <li class=md-nav__item> <a href=../ title=React class=md-nav__link> React </a> </li> <li class=md-nav__item> <a href=../../react-native/ title="React Native" class=md-nav__link> React Native </a> </li> <li class=md-nav__item> <a href=../../redux-saga/ title="Redux Saga" class=md-nav__link> Redux Saga </a> </li> <li class=md-nav__item> <a href=../../rxjs/ title=RxJS class=md-nav__link> RxJS </a> </li> <li class=md-nav__item> <a href=../../mysql/ title=MySQL class=md-nav__link> MySQL </a> </li> <li class=md-nav__item> <a href=../../mongodb/ title=MongoDB class=md-nav__link> MongoDB </a> </li> <li class=md-nav__item> <a href=../../firebase/ title=Firebase class=md-nav__link> Firebase </a> </li> <li class=md-nav__item> <a href=../../web-security/ title="Web Security" class=md-nav__link> Web Security </a> </li> <li class=md-nav__item> <a href=../../rust/ title=Rust class=md-nav__link> Rust </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary"> <label class=md-nav__title for=__toc>Table of contents</label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#when-to-use-derived-state class=md-nav__link> When to Use Derived State </a> </li> <li class=md-nav__item> <a href=#common-bugs-when-using-derived-state class=md-nav__link> Common Bugs When Using Derived State </a> <nav class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a href=#anti-pattern-unconditionally-copying-props-to-state class=md-nav__link> Anti-pattern: Unconditionally copying props to state </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#preferred-solutions class=md-nav__link> Preferred Solutions </a> <nav class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a href=#recommendation-fully-controlled-component class=md-nav__link> Recommendation: Fully controlled component </a> </li> <li class=md-nav__item> <a href=#recommendation-fully-uncontrolled-component-with-a-key class=md-nav__link> Recommendation: Fully uncontrolled component with a key </a> <nav class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a href=#alternative-1-reset-uncontrolled-component-with-an-id-prop class=md-nav__link> Alternative 1: Reset uncontrolled component with an ID prop </a> </li> <li class=md-nav__item> <a href=#alternative-2-reset-uncontrolled-component-with-an-instance-method class=md-nav__link> Alternative 2: Reset uncontrolled component with an instance method </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#recap class=md-nav__link> Recap </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#what-about-memoization class=md-nav__link> What about memoization </a> </li> <li class=md-nav__item> <a href=#in-closing class=md-nav__link> In closing </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content> <article class="md-content__inner md-typeset"> <a href=https://github.com/abhaydgarg/Notebook/tree/master/src/react/getDerivedStateFromProps.md title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a> <h1 id=getderivedstatefromprops>getDerivedStateFromProps<a class=headerlink href=#getderivedstatefromprops title="Permanent link">&para;</a></h1> <p><strong>Each property of <code>props</code> or <code>state</code> object must have a single source of truth.</strong></p> <p>For example, say <code>email</code> property of component should either get value from <code>props</code> or <code>state</code>, not from both. It breaks the rule of "Single source of truth". And it becomes hard to track update process because if component update <code>email</code> value from both <code>props</code> and <code>state</code> then it would be difficult to track where the change is coming from. You can copy the <code>props</code> value to <code>state</code> and then uses <code>state</code> value through out the component. The initial copy can be done in constructor and on subsequent <code>props</code> update the state value is then synced in <code>getDerivedStateFromProps</code>.</p> <blockquote> <p>When designing component, be clear about the type of component. Either <code>controlled</code> means only using <code>props</code> or <code>uncontrolled</code> means using only <code>state</code> or combination of both. Whatever you choose, make sure you have single source of truth for both <code>props</code> and <code>state</code>.</p> </blockquote> <p>Deriving state leads to verbose (expressed in more words than are needed) code and makes your components difficult to think about.</p> <p>Make sure you’re familiar with simpler alternatives:</p> <ol> <li> <p>If you need to <strong>perform a side effect</strong> (for example, data fetching or an animation) in response to a change in props, use componentDidUpdate lifecycle instead.</p> </li> <li> <p>If you want to <strong>re-compute some data only when a prop changes</strong>, use a memoization helper instead.</p> </li> <li> <p>If you want to <strong>“reset” some state when a prop changes</strong>, consider either making a component fully controlled or fully uncontrolled with a <strong>key</strong> instead.</p> </li> </ol> <h2 id=when-to-use-derived-state>When to Use Derived State<a class=headerlink href=#when-to-use-derived-state title="Permanent link">&para;</a></h2> <p><code>getDerivedStateFromProps</code> exists for only one purpose. It enables a component to update its internal state as the result of <strong>changes in props</strong>. Our previous blog post provided some examples, like <a href=https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props>recording the current scroll direction based on a changing offset prop</a> or <a href=https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#fetching-external-data-when-props-change>loading external data specified by a source prop</a>.</p> <p>We did not provide many examples, because as a general rule, <strong>derived state should be used sparingly</strong>. All problems with derived state that we have seen can be ultimately reduced to either (1) unconditionally updating state from props or (2) updating state whenever props and state don’t match. (We’ll go over both in more detail below.)</p> <ul> <li>If you’re using derived state to memoize some computation based only on the current props, you don’t need derived state. See <a href=https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#what-about-memoization>What about memoization?</a> below.</li> <li>If you’re updating derived state unconditionally or updating it whenever props and state don’t match, your component likely resets its state too frequently. Read on for more details.</li> </ul> <h2 id=common-bugs-when-using-derived-state>Common Bugs When Using Derived State<a class=headerlink href=#common-bugs-when-using-derived-state title="Permanent link">&para;</a></h2> <p>The terms <a href=https://reactjs.org/docs/forms.html#controlled-components>“controlled”</a> and <a href=https://reactjs.org/docs/uncontrolled-components.html>“uncontrolled”</a> usually refer to form inputs, but they can also describe where any component’s data lives. Data passed in as props can be thought of as <strong>controlled</strong> (because the parent component <em>controls</em> that data). Data that exists only in internal state can be thought of as <strong>uncontrolled</strong> (because the parent can’t directly change it).</p> <p>The most common mistake with derived state is mixing these two; when a derived state value is also updated by <code>setState</code> calls, there isn’t a single source of truth for the data. The <a href=https://reactjs.org/blog/2018/03/27/update-on-async-rendering.html#fetching-external-data-when-props-change>external data loading example</a> mentioned above may sound similar, but it’s different in a few important ways. In the loading example, there is a clear source of truth for both the “source” prop and the “loading” state. When the source prop changes, the loading state should <strong>always</strong> be overridden. Conversely, the state is overridden only when the prop <strong>changes</strong> and is otherwise managed by the component.</p> <p>Problems arise when any of these constraints are changed. This typically comes in two forms. Let’s take a look at both.</p> <h3 id=anti-pattern-unconditionally-copying-props-to-state>Anti-pattern: Unconditionally copying props to state<a class=headerlink href=#anti-pattern-unconditionally-copying-props-to-state title="Permanent link">&para;</a></h3> <p>A common misconception is that <code>getDerivedStateFromProps</code> and <code>componentWillReceiveProps</code> are only called when props “change”. These lifecycles are called any time a parent component rerenders, regardless of whether the props are “different” from before. Because of this, it has always been unsafe to _unconditionally_override state using either of these lifecycles. <strong>Doing so will cause state updates to be lost.</strong></p> <p>Let’s consider an example to demonstrate the problem. Here is a <code>EmailInput</code> component that “mirrors” an email prop in state:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=kr>class</span> <span class=nx>EmailInput</span> <span class=kr>extends</span> <span class=nx>Component</span> <span class=p>{</span>
  <span class=nx>state</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>email</span><span class=o>:</span> <span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>email</span> <span class=p>};</span>

  <span class=nx>render</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=o>&lt;</span><span class=nx>input</span> <span class=nx>onChange</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>handleChange</span><span class=p>}</span> <span class=nx>value</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>state</span><span class=p>.</span><span class=nx>email</span><span class=p>}</span> <span class=o>/&gt;</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=nx>handleChange</span> <span class=o>=</span> <span class=nx>event</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=k>this</span><span class=p>.</span><span class=nx>setState</span><span class=p>({</span> <span class=nx>email</span><span class=o>:</span> <span class=nx>event</span><span class=p>.</span><span class=nx>target</span><span class=p>.</span><span class=nx>value</span> <span class=p>});</span>
  <span class=p>};</span>

  <span class=nx>componentWillReceiveProps</span><span class=p>(</span><span class=nx>nextProps</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// This will erase any local state updates!</span>
    <span class=c1>// Do not do this.</span>
    <span class=k>this</span><span class=p>.</span><span class=nx>setState</span><span class=p>({</span> <span class=nx>email</span><span class=o>:</span> <span class=nx>nextProps</span><span class=p>.</span><span class=nx>email</span> <span class=p>});</span>
  <span class=p>}</span>
<span class=p>}</span>
</pre></div> </td></tr></table> <p>At first, this component might look okay. State is initialized to the value specified by props and updated when we type into the <code>&lt;input&gt;</code>. But if our component’s parent rerenders, anything we’ve typed into the <code>&lt;input&gt;</code> will be lost! (<a href=https://codesandbox.io/s/m3w9zn1z8x>See this demo for an example.</a>) This holds true even if we were to compare <code>nextProps.email !== this.state.email</code> before resetting.</p> <p>In this simple example, adding <code>shouldComponentUpdate</code> to rerender only when the email prop has changed could fix this. However in practice, components usually accept multiple props; another prop changing would still cause a rerender and improper reset. Function and object props are also often created inline, making it hard to implement a <code>shouldComponentUpdate</code> that reliably returns true only when a material change has happened. <a href=https://codesandbox.io/s/jl0w6r9w59>Here is a demo that shows that happening.</a> As a result, <code>shouldComponentUpdate</code> is best used as a performance optimization, not to ensure correctness of derived state.</p> <p>Hopefully it’s clear by now why <strong>it is a bad idea to unconditionally copy props to state</strong>. Before reviewing possible solutions, let’s look at a related problematic pattern: what if we were to only update the state when the email prop changes?</p> <p>Anti-pattern: Erasing state when props change Continuing the example above, we could avoid accidentally erasing state by only updating it when props.email changes:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=kr>class</span> <span class=nx>EmailInput</span> <span class=kr>extends</span> <span class=nx>Component</span> <span class=p>{</span>
  <span class=nx>state</span> <span class=o>=</span> <span class=p>{</span>
    <span class=nx>email</span><span class=o>:</span> <span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>email</span>
  <span class=p>};</span>

  <span class=nx>componentWillReceiveProps</span><span class=p>(</span><span class=nx>nextProps</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Any time props.email changes, update state.</span>
    <span class=k>if</span> <span class=p>(</span><span class=nx>nextProps</span><span class=p>.</span><span class=nx>email</span> <span class=o>!==</span> <span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>email</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>this</span><span class=p>.</span><span class=nx>setState</span><span class=p>({</span>
        <span class=nx>email</span><span class=o>:</span> <span class=nx>nextProps</span><span class=p>.</span><span class=nx>email</span>
      <span class=p>});</span>
    <span class=p>}</span>
  <span class=p>}</span>

  <span class=c1>// ...</span>
<span class=p>}</span>
</pre></div> </td></tr></table> <blockquote> <p>Even though the example above shows componentWillReceiveProps, the same anti-pattern applies to getDerivedStateFromProps.</p> </blockquote> <p>We’ve just made a big improvement. Now our component will erase what we’ve typed only when the props actually change.</p> <p>There is still a subtle problem. Imagine a password manager app using the above input component. When navigating between details for two accounts with the same email, the input would fail to reset. This is because the prop value passed to the component would be the same for both accounts! This would be a surprise to the user, as an unsaved change to one account would appear to affect other accounts that happened to share the same email. (See demo here.)</p> <p>This design is fundamentally flawed, but it’s also an easy mistake to make. (I’ve made it myself!) Fortunately there are two alternatives that work better. The key to both is that for any piece of data, you need to pick a single component that owns it as the source of truth, and avoid duplicating it in other components. Let’s take a look at each of the alternatives.</p> <h2 id=preferred-solutions>Preferred Solutions<a class=headerlink href=#preferred-solutions title="Permanent link">&para;</a></h2> <h3 id=recommendation-fully-controlled-component><a href=https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-controlled-component></a>Recommendation: Fully controlled component<a class=headerlink href=#recommendation-fully-controlled-component title="Permanent link">&para;</a></h3> <p>One way to avoid the problems mentioned above is to remove state from our component entirely. If the email address only exists as a prop, then we don’t have to worry about conflicts with state. We could even convert <code>EmailInput</code> to a lighter-weight function component:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre>1
2
3</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=kd>function</span> <span class=nx>EmailInput</span><span class=p>(</span><span class=nx>props</span><span class=p>)</span> <span class=p>{</span>
  <span class=k>return</span> <span class=o>&lt;</span><span class=nx>input</span> <span class=nx>onChange</span><span class=o>=</span><span class=p>{</span><span class=nx>props</span><span class=p>.</span><span class=nx>onChange</span><span class=p>}</span> <span class=nx>value</span><span class=o>=</span><span class=p>{</span><span class=nx>props</span><span class=p>.</span><span class=nx>email</span><span class=p>}</span> <span class=o>/&gt;</span><span class=p>;</span>
<span class=p>}</span>
</pre></div> </td></tr></table> <p>This approach simplifies the implementation of our component, but if we still want to store a draft value, the parent form component will now need to do that manually. (<a href=https://codesandbox.io/s/7154w1l551>Click here to see a demo of this pattern.</a>)</p> <h3 id=recommendation-fully-uncontrolled-component-with-a-key>Recommendation: Fully uncontrolled component with a <code>key</code><a class=headerlink href=#recommendation-fully-uncontrolled-component-with-a-key title="Permanent link">&para;</a></h3> <p>Another alternative would be for our component to fully own the “draft” email state. In that case, our component could still accept a prop for the <em>initial</em> value, but it would ignore subsequent changes to that prop:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=kr>class</span> <span class=nx>EmailInput</span> <span class=kr>extends</span> <span class=nx>Component</span> <span class=p>{</span>
  <span class=nx>state</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>email</span><span class=o>:</span> <span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>defaultEmail</span> <span class=p>};</span>

  <span class=nx>handleChange</span> <span class=o>=</span> <span class=nx>event</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=k>this</span><span class=p>.</span><span class=nx>setState</span><span class=p>({</span> <span class=nx>email</span><span class=o>:</span> <span class=nx>event</span><span class=p>.</span><span class=nx>target</span><span class=p>.</span><span class=nx>value</span> <span class=p>});</span>
  <span class=p>};</span>

  <span class=nx>render</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=o>&lt;</span><span class=nx>input</span> <span class=nx>onChange</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>handleChange</span><span class=p>}</span> <span class=nx>value</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>state</span><span class=p>.</span><span class=nx>email</span><span class=p>}</span> <span class=o>/&gt;</span><span class=p>;</span>
  <span class=p>}</span>
<span class=p>}</span>
</pre></div> </td></tr></table> <p>In order to reset the value when moving to a different item (as in our password manager scenario), we can use the special React attribute called <code>key</code>. When a <code>key</code> changes, React will <a href=https://reactjs.org/docs/reconciliation.html#keys><em>create</em> a new component instance rather than <em>update</em> the current one</a>. Keys are usually used for dynamic lists but are also useful here. In our case, we could use the user ID to recreate the email input any time a new user is selected:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre>1
2
3
4</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=o>&lt;</span><span class=nx>EmailInput</span>
  <span class=nx>defaultEmail</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>user</span><span class=p>.</span><span class=nx>email</span><span class=p>}</span>
  <span class=nx>key</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>user</span><span class=p>.</span><span class=nx>id</span><span class=p>}</span>
<span class=err>/&gt;</span>
</pre></div> </td></tr></table> <p>Each time the ID changes, the <code>EmailInput</code> will be recreated and its state will be reset to the latest <code>defaultEmail</code> value. (<a href=https://codesandbox.io/s/6v1znlxyxn>Click here to see a demo of this pattern.</a>) With this approach, you don’t have to add <code>key</code> to every input. It might make more sense to put a <code>key</code> on the whole form instead. Every time the key changes, all components within the form will be recreated with a freshly initialized state.</p> <p>In most cases, this is the best way to handle state that needs to be reset.</p> <blockquote> <p>While this may sound slow, the performance difference is usually insignificant. Using a key can even be faster if the components have heavy logic that runs on updates since diffing gets bypassed for that subtree.</p> </blockquote> <h4 id=alternative-1-reset-uncontrolled-component-with-an-id-prop>Alternative 1: Reset uncontrolled component with an ID prop<a class=headerlink href=#alternative-1-reset-uncontrolled-component-with-an-id-prop title="Permanent link">&para;</a></h4> <p>If <code>key</code> doesn’t work for some reason (perhaps the component is very expensive to initialize), a workable but cumbersome solution would be to watch for changes to “userID” in <code>getDerivedStateFromProps</code>:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=kr>class</span> <span class=nx>EmailInput</span> <span class=kr>extends</span> <span class=nx>Component</span> <span class=p>{</span>
  <span class=nx>state</span> <span class=o>=</span> <span class=p>{</span>
    <span class=nx>email</span><span class=o>:</span> <span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>defaultEmail</span><span class=p>,</span>
    <span class=nx>prevPropsUserID</span><span class=o>:</span> <span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>userID</span>
  <span class=p>};</span>

  <span class=kr>static</span> <span class=nx>getDerivedStateFromProps</span><span class=p>(</span><span class=nx>props</span><span class=p>,</span> <span class=nx>state</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Any time the current user changes,</span>
    <span class=c1>// Reset any parts of state that are tied to that user.</span>
    <span class=c1>// In this simple example, that&#39;s just the email.</span>
    <span class=k>if</span> <span class=p>(</span><span class=nx>props</span><span class=p>.</span><span class=nx>userID</span> <span class=o>!==</span> <span class=nx>state</span><span class=p>.</span><span class=nx>prevPropsUserID</span><span class=p>)</span> <span class=p>{</span>
      <span class=k>return</span> <span class=p>{</span>
        <span class=nx>prevPropsUserID</span><span class=o>:</span> <span class=nx>props</span><span class=p>.</span><span class=nx>userID</span><span class=p>,</span>
        <span class=nx>email</span><span class=o>:</span> <span class=nx>props</span><span class=p>.</span><span class=nx>defaultEmail</span>
      <span class=p>};</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>null</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=c1>// ...</span>
<span class=p>}</span>
</pre></div> </td></tr></table> <p>This also provides the flexibility to only reset parts of our component’s internal state if we so choose. (<a href=https://codesandbox.io/s/rjyvp7l3rq>Click here to see a demo of this pattern.</a>)</p> <blockquote> <p>Even though the example above shows <code>getDerivedStateFromProps</code>, the same technique can be used with <code>componentWillReceiveProps</code>.</p> </blockquote> <h4 id=alternative-2-reset-uncontrolled-component-with-an-instance-method>Alternative 2: Reset uncontrolled component with an instance method<a class=headerlink href=#alternative-2-reset-uncontrolled-component-with-an-instance-method title="Permanent link">&para;</a></h4> <p>More rarely, you may need to reset state even if there’s no appropriate ID to use as <code>key</code>. One solution is to reset the key to a random value or autoincrementing number each time you want to reset. One other viable alternative is to expose an instance method to imperatively reset the internal state:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=kr>class</span> <span class=nx>EmailInput</span> <span class=kr>extends</span> <span class=nx>Component</span> <span class=p>{</span>
  <span class=nx>state</span> <span class=o>=</span> <span class=p>{</span>
    <span class=nx>email</span><span class=o>:</span> <span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>defaultEmail</span>
  <span class=p>};</span>

  <span class=nx>resetEmailForNewUser</span><span class=p>(</span><span class=nx>newEmail</span><span class=p>)</span> <span class=p>{</span>
    <span class=k>this</span><span class=p>.</span><span class=nx>setState</span><span class=p>({</span> <span class=nx>email</span><span class=o>:</span> <span class=nx>newEmail</span> <span class=p>});</span>
  <span class=p>}</span>

  <span class=c1>// ...</span>
<span class=p>}</span>
</pre></div> </td></tr></table> <p>The parent form component could then <a href=https://reactjs.org/docs/glossary.html#refs>use a <code>ref</code> to call this method</a>. (<a href=https://codesandbox.io/s/l70krvpykl>Click here to see a demo of this pattern.</a>)</p> <p>Refs can be useful in certain cases like this one, but generally we recommend you use them sparingly. Even in the demo, this imperative method is nonideal because two renders will occur instead of one.</p> <h3 id=recap>Recap<a class=headerlink href=#recap title="Permanent link">&para;</a></h3> <p>To recap, when designing a component, it is important to decide whether its data will be controlled or uncontrolled.</p> <p>Instead of trying to <strong>“mirror” a prop value in state</strong>, make the component <strong>controlled</strong>, and consolidate the two diverging values in the state of some parent component. For example, rather than a child accepting a “committed” <code>props.value</code> and tracking a “draft” <code>state.value</code>, have the parent manage both <code>state.draftValue</code> and <code>state.committedValue</code> and control the child’s value directly. This makes the data flow more explicit and predictable.</p> <p>For <strong>uncontrolled</strong> components, if you’re trying to reset state when a particular prop (usually an ID) changes, you have a few options:</p> <ul> <li><strong>Recomendation: To reset <em>all internal state</em>, use the <code>key</code> attribute.</strong></li> <li>Alternative 1: To reset <em>only certain state fields</em>, watch for changes in a special property (e.g. <code>props.userID</code>).</li> <li>Alternative 2: You can also consider fall back to an imperative instance method using refs.</li> </ul> <h2 id=what-about-memoization>What about memoization<a class=headerlink href=#what-about-memoization title="Permanent link">&para;</a></h2> <p>We’ve also seen derived state used to ensure an expensive value used in <code>render</code> is recomputed only when the inputs change. This technique is known as <a href=https://en.wikipedia.org/wiki/Memoization>memoization</a>.</p> <p>Using derived state for memoization isn’t necessarily bad, but it’s usually not the best solution. There is inherent complexity in managing derived state, and this complexity increases with each additional property. For example, if we add a second derived field to our component state then our implementation would need to separately track changes to both.</p> <p>Let’s look at an example of one component that takes one prop—a list of items—and renders the items that match a search query entered by the user. We could use derived state to store the filtered list:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=kr>class</span> <span class=nx>Example</span> <span class=kr>extends</span> <span class=nx>Component</span> <span class=p>{</span>
  <span class=nx>state</span> <span class=o>=</span> <span class=p>{</span>
    <span class=nx>filterText</span><span class=o>:</span> <span class=s2>&quot;&quot;</span><span class=p>,</span>
  <span class=p>};</span>

  <span class=c1>// *******************************************************</span>
  <span class=c1>// NOTE: this example is NOT the recommended approach.</span>
  <span class=c1>// See the examples below for our recommendations instead.</span>
  <span class=c1>// *******************************************************</span>

  <span class=kr>static</span> <span class=nx>getDerivedStateFromProps</span><span class=p>(</span><span class=nx>props</span><span class=p>,</span> <span class=nx>state</span><span class=p>)</span> <span class=p>{</span>
    <span class=c1>// Re-run the filter whenever the list array or filter text change.</span>
    <span class=c1>// Note we need to store prevPropsList and prevFilterText to detect changes.</span>
    <span class=k>if</span> <span class=p>(</span>
      <span class=nx>props</span><span class=p>.</span><span class=nx>list</span> <span class=o>!==</span> <span class=nx>state</span><span class=p>.</span><span class=nx>prevPropsList</span> <span class=o>||</span>
      <span class=nx>state</span><span class=p>.</span><span class=nx>prevFilterText</span> <span class=o>!==</span> <span class=nx>state</span><span class=p>.</span><span class=nx>filterText</span>
    <span class=p>)</span> <span class=p>{</span>
      <span class=k>return</span> <span class=p>{</span>
        <span class=nx>prevPropsList</span><span class=o>:</span> <span class=nx>props</span><span class=p>.</span><span class=nx>list</span><span class=p>,</span>
        <span class=nx>prevFilterText</span><span class=o>:</span> <span class=nx>state</span><span class=p>.</span><span class=nx>filterText</span><span class=p>,</span>
        <span class=nx>filteredList</span><span class=o>:</span> <span class=nx>props</span><span class=p>.</span><span class=nx>list</span><span class=p>.</span><span class=nx>filter</span><span class=p>(</span><span class=nx>item</span> <span class=p>=&gt;</span> <span class=nx>item</span><span class=p>.</span><span class=nx>text</span><span class=p>.</span><span class=nx>includes</span><span class=p>(</span><span class=nx>state</span><span class=p>.</span><span class=nx>filterText</span><span class=p>))</span>
      <span class=p>};</span>
    <span class=p>}</span>
    <span class=k>return</span> <span class=kc>null</span><span class=p>;</span>
  <span class=p>}</span>

  <span class=nx>handleChange</span> <span class=o>=</span> <span class=nx>event</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=k>this</span><span class=p>.</span><span class=nx>setState</span><span class=p>({</span> <span class=nx>filterText</span><span class=o>:</span> <span class=nx>event</span><span class=p>.</span><span class=nx>target</span><span class=p>.</span><span class=nx>value</span> <span class=p>});</span>
  <span class=p>};</span>

  <span class=nx>render</span><span class=p>()</span> <span class=p>{</span>
    <span class=k>return</span> <span class=p>(</span>
      <span class=o>&lt;</span><span class=nx>Fragment</span><span class=o>&gt;</span>
        <span class=o>&lt;</span><span class=nx>input</span> <span class=nx>onChange</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>handleChange</span><span class=p>}</span> <span class=nx>value</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>state</span><span class=p>.</span><span class=nx>filterText</span><span class=p>}</span> <span class=o>/&gt;</span>
        <span class=o>&lt;</span><span class=nx>ul</span><span class=o>&gt;</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>state</span><span class=p>.</span><span class=nx>filteredList</span><span class=p>.</span><span class=nx>map</span><span class=p>(</span><span class=nx>item</span> <span class=p>=&gt;</span> <span class=o>&lt;</span><span class=nx>li</span> <span class=nx>key</span><span class=o>=</span><span class=p>{</span><span class=nx>item</span><span class=p>.</span><span class=nx>id</span><span class=p>}</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>item</span><span class=p>.</span><span class=nx>text</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/li&gt;)}&lt;/ul&gt;</span>
      <span class=o>&lt;</span><span class=err>/Fragment&gt;</span>
    <span class=p>);</span>
  <span class=p>}</span>
<span class=p>}</span>
</pre></div> </td></tr></table> <p>This implementation avoids recalculating <code>filteredList</code> more often than necessary. But it is more complicated than it needs to be, because it has to separately track and detect changes in both props and state in order to properly update the filtered list. In this example, we could simplify things by using <code>PureComponent</code> and moving the filter operation into the render method:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=c1>// PureComponents only rerender if at least one state or prop value changes.</span>
<span class=c1>// Change is determined by doing a shallow comparison of state and prop keys.</span>
<span class=kr>class</span> <span class=nx>Example</span> <span class=kr>extends</span> <span class=nx>PureComponent</span> <span class=p>{</span>
  <span class=c1>// State only needs to hold the current filter text value:</span>
  <span class=nx>state</span> <span class=o>=</span> <span class=p>{</span>
    <span class=nx>filterText</span><span class=o>:</span> <span class=s2>&quot;&quot;</span>
  <span class=p>};</span>

  <span class=nx>handleChange</span> <span class=o>=</span> <span class=nx>event</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=k>this</span><span class=p>.</span><span class=nx>setState</span><span class=p>({</span> <span class=nx>filterText</span><span class=o>:</span> <span class=nx>event</span><span class=p>.</span><span class=nx>target</span><span class=p>.</span><span class=nx>value</span> <span class=p>});</span>
  <span class=p>};</span>

  <span class=nx>render</span><span class=p>()</span> <span class=p>{</span>
    <span class=c1>// The render method on this PureComponent is called only if</span>
    <span class=c1>// props.list or state.filterText has changed.</span>
    <span class=kr>const</span> <span class=nx>filteredList</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>list</span><span class=p>.</span><span class=nx>filter</span><span class=p>(</span>
      <span class=nx>item</span> <span class=p>=&gt;</span> <span class=nx>item</span><span class=p>.</span><span class=nx>text</span><span class=p>.</span><span class=nx>includes</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>state</span><span class=p>.</span><span class=nx>filterText</span><span class=p>)</span>
    <span class=p>)</span>

    <span class=k>return</span> <span class=p>(</span>
      <span class=o>&lt;</span><span class=nx>Fragment</span><span class=o>&gt;</span>
        <span class=o>&lt;</span><span class=nx>input</span> <span class=nx>onChange</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>handleChange</span><span class=p>}</span> <span class=nx>value</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>state</span><span class=p>.</span><span class=nx>filterText</span><span class=p>}</span> <span class=o>/&gt;</span>
        <span class=o>&lt;</span><span class=nx>ul</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>filteredList</span><span class=p>.</span><span class=nx>map</span><span class=p>(</span><span class=nx>item</span> <span class=p>=&gt;</span> <span class=o>&lt;</span><span class=nx>li</span> <span class=nx>key</span><span class=o>=</span><span class=p>{</span><span class=nx>item</span><span class=p>.</span><span class=nx>id</span><span class=p>}</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>item</span><span class=p>.</span><span class=nx>text</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/li&gt;)}&lt;/ul&gt;</span>
      <span class=o>&lt;</span><span class=err>/Fragment&gt;</span>
    <span class=p>);</span>
  <span class=p>}</span>
<span class=p>}</span>
</pre></div> </td></tr></table> <p>The above approach is much cleaner and simpler than the derived state version. Occasionally, this won’t be good enough—filtering may be slow for large lists, and <code>PureComponent</code> won’t prevent rerenders if another prop were to change. To address both of these concerns, we could add a memoization helper to avoid unnecessarily re-filtering our list:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=kr>import</span> <span class=nx>memoize</span> <span class=nx>from</span> <span class=s2>&quot;memoize-one&quot;</span><span class=p>;</span>

<span class=kr>class</span> <span class=nx>Example</span> <span class=kr>extends</span> <span class=nx>Component</span> <span class=p>{</span>
  <span class=c1>// State only needs to hold the current filter text value:</span>
  <span class=nx>state</span> <span class=o>=</span> <span class=p>{</span> <span class=nx>filterText</span><span class=o>:</span> <span class=s2>&quot;&quot;</span> <span class=p>};</span>

  <span class=c1>// Re-run the filter whenever the list array or filter text changes:</span>
  <span class=nx>filter</span> <span class=o>=</span> <span class=nx>memoize</span><span class=p>(</span>
    <span class=p>(</span><span class=nx>list</span><span class=p>,</span> <span class=nx>filterText</span><span class=p>)</span> <span class=p>=&gt;</span> <span class=nx>list</span><span class=p>.</span><span class=nx>filter</span><span class=p>(</span><span class=nx>item</span> <span class=p>=&gt;</span> <span class=nx>item</span><span class=p>.</span><span class=nx>text</span><span class=p>.</span><span class=nx>includes</span><span class=p>(</span><span class=nx>filterText</span><span class=p>))</span>
  <span class=p>);</span>

  <span class=nx>handleChange</span> <span class=o>=</span> <span class=nx>event</span> <span class=p>=&gt;</span> <span class=p>{</span>
    <span class=k>this</span><span class=p>.</span><span class=nx>setState</span><span class=p>({</span> <span class=nx>filterText</span><span class=o>:</span> <span class=nx>event</span><span class=p>.</span><span class=nx>target</span><span class=p>.</span><span class=nx>value</span> <span class=p>});</span>
  <span class=p>};</span>

  <span class=nx>render</span><span class=p>()</span> <span class=p>{</span>
    <span class=c1>// Calculate the latest filtered list. If these arguments haven&#39;t changed</span>
    <span class=c1>// since the last render, `memoize-one` will reuse the last return value.</span>
    <span class=kr>const</span> <span class=nx>filteredList</span> <span class=o>=</span> <span class=k>this</span><span class=p>.</span><span class=nx>filter</span><span class=p>(</span><span class=k>this</span><span class=p>.</span><span class=nx>props</span><span class=p>.</span><span class=nx>list</span><span class=p>,</span> <span class=k>this</span><span class=p>.</span><span class=nx>state</span><span class=p>.</span><span class=nx>filterText</span><span class=p>);</span>

    <span class=k>return</span> <span class=p>(</span>
      <span class=o>&lt;</span><span class=nx>Fragment</span><span class=o>&gt;</span>
        <span class=o>&lt;</span><span class=nx>input</span> <span class=nx>onChange</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>handleChange</span><span class=p>}</span> <span class=nx>value</span><span class=o>=</span><span class=p>{</span><span class=k>this</span><span class=p>.</span><span class=nx>state</span><span class=p>.</span><span class=nx>filterText</span><span class=p>}</span> <span class=o>/&gt;</span>
        <span class=o>&lt;</span><span class=nx>ul</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>filteredList</span><span class=p>.</span><span class=nx>map</span><span class=p>(</span><span class=nx>item</span> <span class=p>=&gt;</span> <span class=o>&lt;</span><span class=nx>li</span> <span class=nx>key</span><span class=o>=</span><span class=p>{</span><span class=nx>item</span><span class=p>.</span><span class=nx>id</span><span class=p>}</span><span class=o>&gt;</span><span class=p>{</span><span class=nx>item</span><span class=p>.</span><span class=nx>text</span><span class=p>}</span><span class=o>&lt;</span><span class=err>/li&gt;)}&lt;/ul&gt;</span>
      <span class=o>&lt;</span><span class=err>/Fragment&gt;</span>
    <span class=p>);</span>
  <span class=p>}</span>
<span class=p>}</span>
</pre></div> </td></tr></table> <p>This is much simpler and performs just as well as the derived state version!</p> <p>When using memoization, remember a couple of constraints:</p> <ol> <li>In most cases, you’ll want to <strong>attach the memoized function to a component instance</strong>. This prevents multiple instances of a component from resetting each other’s memoized keys.</li> <li>Typically you’ll want to use a memoization helper with a <strong>limited cache size</strong> in order to prevent memory leaks over time. (In the example above, we used <code>memoize-one</code> because it only caches the most recent arguments and result.)</li> <li>None of the implementations shown in this section will work if <code>props.list</code> is recreated each time the parent component renders. But in most cases, this setup is appropriate.</li> </ol> <h2 id=in-closing>In closing<a class=headerlink href=#in-closing title="Permanent link">&para;</a></h2> <p>In real world applications, <strong>components often contain a mix of controlled and uncontrolled behaviors</strong>. This is okay! <strong>If each value has a clear source of truth</strong>, you can avoid the anti-patterns mentioned above.</p> </article> </div> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> <div class=md-footer-copyright__highlight> Abhay Garg </div> powered by <a href=https://www.mkdocs.org>MkDocs</a> and <a href=https://squidfunk.github.io/mkdocs-material/ > Material for MkDocs</a> </div> </div> </div> </footer> </div> <script src=../../assets/javascripts/application.c648116f.js></script> <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>