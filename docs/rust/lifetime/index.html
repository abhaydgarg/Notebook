<!doctype html><html lang=en class=no-js> <head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta http-equiv=x-ua-compatible content="ie=edge"><meta name=description content="Notebook collections"><link href=https://abhaydgarg.github.io/Notebook/index.html/rust/lifetime/ rel=canonical><meta name=author content="Abhay Garg"><meta name=lang:clipboard.copy content="Copy to clipboard"><meta name=lang:clipboard.copied content="Copied to clipboard"><meta name=lang:search.language content=en><meta name=lang:search.pipeline.stopwords content=True><meta name=lang:search.pipeline.trimmer content=True><meta name=lang:search.result.none content="No matching documents"><meta name=lang:search.result.one content="1 matching document"><meta name=lang:search.result.other content="# matching documents"><meta name=lang:search.tokenizer content=[\s\-]+><link rel="shortcut icon" href=../../assets/images/favicon.png><meta name=generator content="mkdocs-1.0.4, mkdocs-material-4.4.2"><title>Lifetime - Notebook</title><link rel=stylesheet href=../../assets/stylesheets/application.30686662.css><link rel=stylesheet href=../../assets/stylesheets/application-palette.a8b3c06d.css><meta name=theme-color content=#2196f3><script src=../../assets/javascripts/modernizr.74668098.js></script><link href=https://fonts.gstatic.com rel=preconnect crossorigin><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Ubuntu:300,400,400i,700|Ubuntu+Mono&display=fallback"><style>body,input{font-family:"Ubuntu","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Ubuntu Mono","Courier New",Courier,monospace}</style><link rel=stylesheet href=../../assets/fonts/material-icons.css></head> <body dir=ltr data-md-color-primary=blue data-md-color-accent=blue> <svg class=md-svg> <defs> <svg xmlns=http://www.w3.org/2000/svg width=416 height=448 viewbox="0 0 416 448" id=__github><path fill=currentColor d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg> </defs> </svg> <input class=md-toggle data-md-toggle=drawer type=checkbox id=__drawer autocomplete=off> <input class=md-toggle data-md-toggle=search type=checkbox id=__search autocomplete=off> <label class=md-overlay data-md-component=overlay for=__drawer></label> <a href=#lifetime tabindex=1 class=md-skip> Skip to content </a> <header class=md-header data-md-component=header> <nav class="md-header-nav md-grid"> <div class=md-flex> <div class="md-flex__cell md-flex__cell--shrink"> <a href=https://abhaydgarg.github.io/Notebook/index.html title=Notebook class="md-header-nav__button md-logo"> <i class=md-icon></i> </a> </div> <div class="md-flex__cell md-flex__cell--shrink"> <label class="md-icon md-icon--menu md-header-nav__button" for=__drawer></label> </div> <div class="md-flex__cell md-flex__cell--stretch"> <div class="md-flex__ellipsis md-header-nav__title" data-md-component=title> <span class=md-header-nav__topic> Notebook </span> <span class=md-header-nav__topic> Lifetime </span> </div> </div> <div class="md-flex__cell md-flex__cell--shrink"> </div> <div class="md-flex__cell md-flex__cell--shrink"> <div class=md-header-nav__source> <a href=https://github.com/abhaydgarg/Notebook/ title="Go to repository" class=md-source data-md-source=github> <div class=md-source__icon> <svg viewbox="0 0 24 24" width=24 height=24> <use xlink:href=#__github width=24 height=24></use> </svg> </div> <div class=md-source__repository> GitHub </div> </a> </div> </div> </div> </nav> </header> <div class=md-container> <main class=md-main role=main> <div class="md-main__inner md-grid" data-md-component=container> <div class="md-sidebar md-sidebar--primary" data-md-component=navigation> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--primary" data-md-level=0> <label class="md-nav__title md-nav__title--site" for=__drawer> <a href=https://abhaydgarg.github.io/Notebook/index.html title=Notebook class="md-nav__button md-logo"> <i class=md-icon></i> </a> Notebook </label> <div class=md-nav__source> <a href=https://github.com/abhaydgarg/Notebook/ title="Go to repository" class=md-source data-md-source=github> <div class=md-source__icon> <svg viewbox="0 0 24 24" width=24 height=24> <use xlink:href=#__github width=24 height=24></use> </svg> </div> <div class=md-source__repository> GitHub </div> </a> </div> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=../../computer-science/ title=CS class=md-nav__link> CS </a> </li> <li class=md-nav__item> <a href=../../parser/ title=Parser class=md-nav__link> Parser </a> </li> <li class=md-nav__item> <a href=../../data-structure-and-algorithms/ title="Data Structure and Algorithms" class=md-nav__link> Data Structure and Algorithms </a> </li> <li class=md-nav__item> <a href=../../oops/ title=OOPS class=md-nav__link> OOPS </a> </li> <li class=md-nav__item> <a href=../../design-patterns/ title="Design Patterns" class=md-nav__link> Design Patterns </a> </li> <li class=md-nav__item> <a href=../../regex/ title=Regex class=md-nav__link> Regex </a> </li> <li class=md-nav__item> <a href=../../git/ title=GIT class=md-nav__link> GIT </a> </li> <li class=md-nav__item> <a href=../../css/ title=CSS class=md-nav__link> CSS </a> </li> <li class=md-nav__item> <a href=../../linters/ title=Linters class=md-nav__link> Linters </a> </li> <li class=md-nav__item> <a href=../../javascript/ title=Javascript class=md-nav__link> Javascript </a> </li> <li class=md-nav__item> <a href=../../typescript/ title=Typescript class=md-nav__link> Typescript </a> </li> <li class=md-nav__item> <a href=../../nodejs/ title=Node.js class=md-nav__link> Node.js </a> </li> <li class=md-nav__item> <a href=../../react/ title=React class=md-nav__link> React </a> </li> <li class=md-nav__item> <a href=../../react-native/ title="React Native" class=md-nav__link> React Native </a> </li> <li class=md-nav__item> <a href=../../redux-saga/ title="Redux Saga" class=md-nav__link> Redux Saga </a> </li> <li class=md-nav__item> <a href=../../expressjs/ title=Express.js class=md-nav__link> Express.js </a> </li> <li class=md-nav__item> <a href=../../graphql/ title=GraphQL class=md-nav__link> GraphQL </a> </li> <li class=md-nav__item> <a href=../../rxjs/ title=RxJS class=md-nav__link> RxJS </a> </li> <li class=md-nav__item> <a href=../../mysql/ title=MySQL class=md-nav__link> MySQL </a> </li> <li class=md-nav__item> <a href=../../mongodb/ title=MongoDB class=md-nav__link> MongoDB </a> </li> <li class=md-nav__item> <a href=../../web-security/ title="Web Security" class=md-nav__link> Web Security </a> </li> <li class=md-nav__item> <a href=../ title=Rust class=md-nav__link> Rust </a> </li> </ul> </nav> </div> </div> </div> <div class="md-sidebar md-sidebar--secondary" data-md-component=toc> <div class=md-sidebar__scrollwrap> <div class=md-sidebar__inner> <nav class="md-nav md-nav--secondary"> <label class=md-nav__title for=__toc>Table of contents</label> <ul class=md-nav__list data-md-scrollfix> <li class=md-nav__item> <a href=#syntax class=md-nav__link> Syntax </a> </li> <li class=md-nav__item> <a href=#why-is-it-needed class=md-nav__link> Why is it needed? </a> </li> <li class=md-nav__item> <a href=#borrow-checker class=md-nav__link> Borrow checker </a> </li> <li class=md-nav__item> <a href=#problems-when-programmer-has-to-annotate-lifetime-expilictly class=md-nav__link> Problems when programmer has to annotate lifetime expilictly </a> <nav class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a href=#problem-1-borrowed-types-in-a-function class=md-nav__link> Problem 1: Borrowed types in a function </a> <nav class=md-nav> <ul class=md-nav__list> <li class=md-nav__item> <a href=#explicit-annotation class=md-nav__link> Explicit annotation </a> </li> <li class=md-nav__item> <a href=#not-every-parameter-is-required-to-annotate class=md-nav__link> Not every parameter is required to annotate </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#problem-2-storing-a-borrow-in-a-struct class=md-nav__link> Problem 2: Storing a borrow in a struct </a> </li> </ul> </nav> </li> <li class=md-nav__item> <a href=#static-lifetime class=md-nav__link> static lifetime </a> </li> </ul> </nav> </div> </div> </div> <div class=md-content> <article class="md-content__inner md-typeset"> <a href=https://github.com/abhaydgarg/Notebook/tree/master/src/rust/lifetime.md title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a> <h1 id=lifetime>Lifetime<a class=headerlink href=#lifetime title="Permanent link">&para;</a></h1> <blockquote> <p>It is Rust's mechanism to validate references (&amp;).</p> </blockquote> <p>When reference come into picture in your code, then compiler implicitly mark the lifetime of reference. Most of the time programmer need not to mark explicitly rather compiler does it behind the scene. But in some cases when compiler is unable to figure out the lifetime of reference then it ask programmer to explicitly mark the lifetime of reference.</p> <blockquote> <p>Where there is reference or borrow, there is a lifetime.</p> </blockquote> <h2 id=syntax>Syntax<a class=headerlink href=#syntax title="Permanent link">&para;</a></h2> <p>Lifetime annotations have a slightly unusual syntax: the names of lifetime parameters must start with an apostrophe (<code>'</code>) and are usually all lowercase and very short, like generic types.</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre>1
2
3</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=o>&amp;</span><span class=kt>i32</span><span class=w>        </span><span class=c1>// a reference</span>
<span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>i32</span><span class=w>     </span><span class=c1>// a reference with an explicit lifetime</span>
<span class=o>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=k>mut</span><span class=w> </span><span class=kt>i32</span><span class=w> </span><span class=c1>// a mutable reference with an explicit lifetime</span>
</pre></div> </td></tr></table> <h2 id=why-is-it-needed>Why is it needed?<a class=headerlink href=#why-is-it-needed title="Permanent link">&para;</a></h2> <p>To enforce memory safety, compiler mark the lifetime of every refrence in a code to make sure that <strong>any borrow or reference must last no greater than that of the owner.</strong> In other words, compiler shouts an error if it sees that owner is removed from the memory but its reference is still being used. Compiler try to prevent the <strong>Dangling reference</strong> by checking and validating the lifetime of every reference or borrow in a code.</p> <blockquote> <p>Rust enforces [the borrowing rules] through lifetimes. Lifetimes are effectively just names for scopes somewhere in the program. Each reference, and anything that contains a reference, is tagged with a lifetime specifying the scope it's valid for.</p> </blockquote> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=p>{</span><span class=w></span>
<span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>r</span><span class=p>;</span><span class=w></span>

<span class=w>  </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w></span>
<span class=w>    </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>x</span><span class=p>;</span><span class=w></span>
<span class=w>  </span><span class=p>}</span><span class=w> </span><span class=c1>// Error -`x` does not live long enough</span>

<span class=w>  </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&quot;r: {}&quot;</span><span class=p>,</span><span class=w> </span><span class=n>r</span><span class=p>);</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</pre></div> </td></tr></table> <p>The outer scope declares a variable named <code>r</code> with no initial value, and the inner scope declares a variable named <code>x</code> with the initial value of 5. Inside the inner scope, we attempt to set the value of <code>r</code>as a reference to <code>x</code>. Then the inner scope ends, and we attempt to print the value in <code>r</code>. This code won’t compile because the value <code>r</code> is referring to has gone out of scope before we try to use it.</p> <h2 id=borrow-checker>Borrow checker<a class=headerlink href=#borrow-checker title="Permanent link">&para;</a></h2> <blockquote> <p>The Rust compiler has a borrow checker that compares scopes to determine whether all borrows are valid.</p> </blockquote> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>r</span><span class=p>;</span><span class=w>                </span><span class=c1>// ---------+-- &#39;a</span>
<span class=w>                          </span><span class=c1>//          |</span>
<span class=w>    </span><span class=p>{</span><span class=w>                     </span><span class=c1>//          |</span>
<span class=w>        </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>        </span><span class=c1>// -+-- &#39;b  |</span>
<span class=w>        </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>x</span><span class=p>;</span><span class=w>           </span><span class=c1>//  |       |</span>
<span class=w>    </span><span class=p>}</span><span class=w>                     </span><span class=c1>// -+       |</span>
<span class=w>                          </span><span class=c1>//          |</span>
<span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&quot;r: {}&quot;</span><span class=p>,</span><span class=w> </span><span class=n>r</span><span class=p>);</span><span class=w> </span><span class=c1>//          |</span>
<span class=p>}</span><span class=w></span>
</pre></div> </td></tr></table> <p>Here, we’ve annotated the lifetime of <code>r</code> with <code>'a</code> and the lifetime of <code>x</code> with <code>'b</code>. As you can see, the inner <code>'b</code> block is much smaller than the outer <code>'a</code> lifetime block. At compile time, Rust compares the size of the two lifetimes and sees that <code>r</code> has a lifetime of <code>'a</code> but that it refers to memory with a lifetime of <code>'b</code>. The program is rejected because <code>'b</code> is shorter than <code>'a</code>: the subject of the reference doesn’t live as long as the reference.</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre>1
2
3
4
5
6
7
8</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>x</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=mi>5</span><span class=p>;</span><span class=w>            </span><span class=c1>// ----------+-- &#39;b</span>
<span class=w>                          </span><span class=c1>//           |</span>
<span class=w>    </span><span class=kd>let</span><span class=w> </span><span class=n>r</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=o>&amp;</span><span class=n>x</span><span class=p>;</span><span class=w>           </span><span class=c1>// --+-- &#39;a  |</span>
<span class=w>                          </span><span class=c1>//   |       |</span>
<span class=w>    </span><span class=n>println</span><span class=o>!</span><span class=p>(</span><span class=s>&quot;r: {}&quot;</span><span class=p>,</span><span class=w> </span><span class=n>r</span><span class=p>);</span><span class=w> </span><span class=c1>//   |       |</span>
<span class=w>                          </span><span class=c1>// --+       |</span>
<span class=p>}</span><span class=w></span>
</pre></div> </td></tr></table> <p>Here, <code>x</code> has the lifetime <code>'b</code>, which in this case is larger than <code>'a</code>. This means <code>r</code> can reference <code>x</code>because Rust knows that the reference in <code>r</code> will always be valid while <code>x</code> is valid.</p> <h2 id=problems-when-programmer-has-to-annotate-lifetime-expilictly>Problems when programmer has to annotate lifetime expilictly<a class=headerlink href=#problems-when-programmer-has-to-annotate-lifetime-expilictly title="Permanent link">&para;</a></h2> <blockquote> <p>99% of times compiler implicitly annotate the lifetime of references and check them by borrow checker. But in some cases compiler cannot infer or figure out, how to annotate the lifetime of reference, so it asked programmer to do the annotation.</p> </blockquote> <h3 id=problem-1-borrowed-types-in-a-function>Problem 1: Borrowed types in a function<a class=headerlink href=#problem-1-borrowed-types-in-a-function title="Permanent link">&para;</a></h3> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre>1
2
3
4
5
6
7
8</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=c1>// Error - missing lifetime specifier</span>
<span class=k>fn</span> <span class=nf>longest</span><span class=p>(</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=kt>str</span> <span class=p>{</span><span class=w></span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=n>x</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>y</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=n>x</span><span class=w></span>
<span class=w>  </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=n>y</span><span class=w></span>
<span class=w>  </span><span class=p>}</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</pre></div> </td></tr></table> <p>Compiler is unable to annotate the <code>x</code> and <code>y</code> implicitly because either <code>x</code> or <code>y</code> as reference is returned based on the if condition. Compiler does not figure out which reference is going to returned <code>x</code> or <code>y</code> for sure, it could be any one of them at the runtime.</p> <p>As you know, to validate and check the lifetime of returned reference as in example above, compiler uses the borrow checker but it cannot annotate the references in function parameter with lifetime annotaton because Rust can’t tell whether the reference being returned refers to <code>x</code> or <code>y</code>. The borrow checker can’t determine this either, because it doesn’t know how the lifetimes of <code>x</code> and <code>y</code> relate to the lifetime of the return value.</p> <h4 id=explicit-annotation>Explicit annotation<a class=headerlink href=#explicit-annotation title="Permanent link">&para;</a></h4> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=k>fn</span> <span class=nf>longest</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>str</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>  </span><span class=k>if</span><span class=w> </span><span class=n>x</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=o>&gt;</span><span class=w> </span><span class=n>y</span><span class=p>.</span><span class=n>len</span><span class=p>()</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=n>x</span><span class=w></span>
<span class=w>  </span><span class=p>}</span><span class=w> </span><span class=k>else</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>    </span><span class=n>y</span><span class=w></span>
<span class=w>  </span><span class=p>}</span><span class=w></span>
<span class=p>}</span><span class=w></span>
<span class=c1>// We are just telling the compiler that in order to</span>
<span class=c1>// prevent dangling reference of reference returned</span>
<span class=c1>// which is either `x` or `y` in relation to function</span>
<span class=c1>// parameters `x` and `y`, all (parameters `x`, `y` and retruned ref)</span>
<span class=c1>// must have same lifetime. If anyone of them has short lifetime</span>
<span class=c1>// then it cause a dangling reference.</span>
</pre></div> </td></tr></table> <p>The function signature now tells Rust that for some lifetime <code>'a</code>, the function takes two parameters, both of which are string literals that live at least as long as lifetime <code>'a</code>. The function signature also tells Rust that the string literal returned from the function will live at least as long as lifetime <code>'a</code>. These constraints are what we want Rust to enforce. Remember, when we specify the lifetime parameters in this function signature, we’re not changing the lifetimes of any values passed in or returned. Rather, we’re specifying that the borrow checker should reject any values that don’t adhere to these constraints.</p> <h4 id=not-every-parameter-is-required-to-annotate>Not every parameter is required to annotate<a class=headerlink href=#not-every-parameter-is-required-to-annotate title="Permanent link">&para;</a></h4> <blockquote> <p>Ultimately, lifetime syntax is about connecting the lifetimes of various parameters and return values of functions. Once they’re connected, Rust has enough information to allow memory-safe operations and disallow operations that would create dangling pointers or otherwise violate memory safety.</p> </blockquote> <p>The way in which you need to specify lifetime parameters depends on what your function is doing. For example, if we changed the implementation of the <code>longest</code> function to always return the first parameter rather than the longest string slice, we wouldn’t need to specify a lifetime on the <code>y</code>parameter. The following code will compile:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre>1
2
3</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=k>fn</span> <span class=nf>longest</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>str</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>  </span><span class=n>x</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</pre></div> </td></tr></table> <p>In this example, we’ve specified a lifetime parameter <code>'a</code> for the parameter <code>x</code> and the return type, but not for the parameter <code>y</code>, because the lifetime of <code>y</code> does not have any relationship with the lifetime of <code>x</code> or the return value.</p> <p>When returning a reference from a function, the lifetime parameter for the return type needs to match the lifetime parameter for one of the parameters. If the reference returned does <em>not</em> refer to one of the parameters, it must refer to a value created within this function, which would be a dangling reference because the value will go out of scope at the end of the function. Consider this attempted implementation of the <code>longest</code> function that won’t compile:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre>1
2
3
4
5</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=k>fn</span> <span class=nf>longest</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=p>(</span><span class=n>x</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>,</span><span class=w> </span><span class=n>y</span>: <span class=kp>&amp;</span><span class=kt>str</span><span class=p>)</span><span class=w> </span>-&gt; <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=kt>str</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>  </span><span class=kd>let</span><span class=w> </span><span class=n>result</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=nb>String</span>::<span class=n>from</span><span class=p>(</span><span class=s>&quot;really long string&quot;</span><span class=p>);</span><span class=w></span>
<span class=w>  </span><span class=c1>// error[E0597]: `result` does not live long enough</span>
<span class=w>  </span><span class=n>result</span><span class=p>.</span><span class=n>as_str</span><span class=p>()</span><span class=w></span>
<span class=p>}</span><span class=w></span>
</pre></div> </td></tr></table> <p>Here, even though we’ve specified a lifetime parameter <code>'a</code> for the return type, this implementation will fail to compile because the return value lifetime is not related to the lifetime of the parameters at all.</p> <p>The problem is that <code>result</code> goes out of scope and gets cleaned up at the end of the <code>longest</code>function. We’re also trying to return a reference to <code>result</code> from the function. There is no way we can specify lifetime parameters that would change the dangling reference, and Rust won’t let us create a dangling reference. In this case, the best fix would be to return an owned data type rather than a reference so the calling function is then responsible for cleaning up the value.</p> <h3 id=problem-2-storing-a-borrow-in-a-struct>Problem 2: Storing a borrow in a <code>struct</code><a class=headerlink href=#problem-2-storing-a-borrow-in-a-struct title="Permanent link">&para;</a></h3> <p>So far, we’ve only defined structs to hold owned types. It’s possible for structs to hold references, but in that case we would need to add a lifetime annotation on every reference in the struct’s definition.</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre>1
2
3
4
5
6
7
8</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=k>struct</span> <span class=nc>Object</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>  </span><span class=n>number</span>: <span class=kt>u32</span>
<span class=p>}</span><span class=w></span>

<span class=k>struct</span> <span class=nc>Multiplier</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>  </span><span class=n>object</span>: <span class=kp>&amp;</span><span class=nc>Object</span><span class=p>,</span><span class=w></span>
<span class=w>  </span><span class=n>mult</span>: <span class=kt>u32</span>
<span class=p>}</span><span class=w></span>
</pre></div> </td></tr></table> <p>Rust is complaining about not being able to figure your lifetimes out for you. Let’s step through the logic.</p> <ul> <li>We introduce an <code>Objct</code> type,containing a single <code>number</code>. Rust is happy with this idea, as it figures that the <code>nuber</code> will live as long as the <code>Object</code> does.</li> <li>We introduce a <code>Mltiplie</code> type, containing a <code>mult</code> and a <strong>borrow</strong> of an <code>Object</code>. Rust is happy about the <code>mult</code> - it uses the same logic as above - but it doesn’t like the <code>object</code> borrow.</li> <li>The thing is, <code>object</code> could live for any odd lifetime - possibly one <strong>smaller</strong> than the <code>Multiplier</code>’s! Rust wants us to constrain the <code>Multiplier</code> so that it can check your code.</li> </ul> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre>1
2
3
4</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=k>struct</span> <span class=nc>Multiplier</span><span class=o>&lt;</span><span class=na>&#39;a</span><span class=o>&gt;</span><span class=w> </span><span class=p>{</span><span class=w></span>
<span class=w>  </span><span class=n>object</span>: <span class=kp>&amp;</span><span class=na>&#39;a</span><span class=w> </span><span class=n>Object</span><span class=p>,</span><span class=w></span>
<span class=w>  </span><span class=n>mult</span>: <span class=kt>u32</span>
<span class=p>}</span><span class=w></span>
</pre></div> </td></tr></table> <p>Basically, this code says “I have an object here called <code>Multiplier</code> that lives as long as the lifetime <code>'a</code>. Given that lifetime, I have an <code>object</code> inside me that lasts as least as long as <code>'a</code>.” This then “links” the lifetime of a <code>Multiplier</code> to the lifetime of the <code>Object</code> inside it, making sure the <code>Object</code> won’t go away before the <code>Multiplier</code> does.</p> <h2 id=static-lifetime><code>static</code> lifetime<a class=headerlink href=#static-lifetime title="Permanent link">&para;</a></h2> <p>It means that this reference can live for the entire duration of the program. All string literals have the <code>'static</code> lifetime, which we can annotate as follows:</p> <table class=codehilitetable><tr><td class=linenos><div class=linenodiv><pre>1</pre></div></td><td class=code><div class=codehilite><pre><span></span><span class=kd>let</span><span class=w> </span><span class=n>s</span>: <span class=kp>&amp;</span><span class=nb>&#39;static</span><span class=w> </span><span class=kt>str</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s>&quot;I have a static lifetime.&quot;</span><span class=p>;</span><span class=w></span>
</pre></div> </td></tr></table> <p>The text of this string is stored directly in the program’s binary, which is always available. Therefore, the lifetime of all string literals is <code>'static</code>.</p> <p>You might see suggestions to use the <code>'static</code> lifetime in error messages. But before specifying <code>'static</code> as the lifetime for a reference, think about whether the reference you have actually lives the entire lifetime of your program or not. You might consider whether you want it to live that long, even if it could. Most of the time, the problem results from attempting to create a dangling reference or a mismatch of the available lifetimes. In such cases, the solution is fixing those problems, not specifying the <code>'static</code> lifetime.</p> </article> </div> </div> </main> <footer class=md-footer> <div class="md-footer-meta md-typeset"> <div class="md-footer-meta__inner md-grid"> <div class=md-footer-copyright> <div class=md-footer-copyright__highlight> Abhay Garg </div> powered by <a href=https://www.mkdocs.org>MkDocs</a> and <a href=https://squidfunk.github.io/mkdocs-material/ > Material for MkDocs</a> </div> </div> </div> </footer> </div> <script src=../../assets/javascripts/application.c648116f.js></script> <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script> <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML"></script> </body> </html>